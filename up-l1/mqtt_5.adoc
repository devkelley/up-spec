= MQTT 5 Transport Protocol
:toc:
:sectnums:

The key words "*MUST*", "*MUST NOT*", "*REQUIRED*", "*SHALL*", "*SHALL NOT*", "*SHOULD*", "*SHOULD NOT*", "*RECOMMENDED*", "*MAY*", and "*OPTIONAL*" in this document are to be interpreted as described in https://www.rfc-editor.org/info/bcp14[IETF BCP14 (RFC2119 & RFC8174)]

----
SPDX-FileCopyrightText: 2023 Contributors to the Eclipse Foundation

Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.

SPDX-FileType: DOCUMENTATION
SPDX-License-Identifier: Apache-2.0
----

== Overview

MQTT is an OASIS standard messaging protocol for the Internet of Things (IoT). It is designed as an extremely lightweight publish/subscribe messaging transport that is ideal for connecting remote devices with a small code footprint and minimal network bandwidth. MQTT today is used in a wide variety of industries, such as automotive, manufacturing, telecommunications, oil and gas, etc

For more information, please refer to https://mqtt.org/

This document will discuss the uTransport implementation on MQTT 5.

== Specifications

=== UAttribute Mapping

MQTT 5 supports custom header fields, and we leverage this to map the UAttribute values into the MQTT header. Only required uAttribute values are mapped into their own UserProperty fields.

[cols="1,1"]
|===
| MQTT Header Property Code | Value (key:value)
| UserProperty
| ("1", "{UAttribute.id}") # UUID id
| UserProperty
| ("2", "{UAttribute.type}") # UMessageType
| UserProperty
| ("3","{UAttribute.source}") # Short Form Serialized Source UURI
| UserProperty
| ("4","{UAttribute.sink}") # Short Form Serialized Sink UURI
| UserProperty
| ("5","{UAttribute.priority}") # UPriority
| UserProperty
| ("9", "{UAttribute.reqId}") # UUID reqid
| UserProperty
| ("opt_ua", "{byte array of remaining UAttributes}") # Remaining UAttributes
|===

All required uAttributes are mapped to a MQTT header UserProperty, where the key is the UAttribute protobuf field number.

The source and sink fields **MUST** be a short form serialized UUri.

Optional uAttributes will be a string representation of a byte array under the UserProperty field with key "opt_ua". This is done to reduce the size of the overall payload. Protobuf serialized byte arrays do not include values in a protobuf message object that are not set, so the byte array will only include the optional UAttributes that are set.

=== URI Mapping to MQTT topics

The MQTT topic a message is published on utilizes elements from both the source and sink UUri fields. Which elements from the UUri are used in the topic depend on whether the sink UUri is present.

Has sink UUri:

`{source.authority.domain}/{source.authority.name}/{sink.authority.domain + ":" + sink.authority.name}/{sink.entity.id}/{sink.entity.version_major}/{sink.resource.id}`

No sink UUri (Publish message type only):

`{source.authority.domain}/{source.authority.name}//{source.entity.id}/{source.entity.version_major}/{source.resource.id}`

The entity and resource elements always represent the destination of the message. In the case of a Publish message type, the destination happens to be based on the source UUri. The source authority information is also always present to allow for authorization controls based on the authority information, since an authority maps to the uE sending the message. The domain information is included is separated out as well to allow for the cloud to easily subscribe to messages from devices only.

Below are examples of messages being sent and how to subscribe to those messages:

==== Example 1: Notification or RPC Message Types

[source]
----
source:
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    domain: veh.com,
  },
  entity: UEntity {
    version_major: 1,
    id: 1234,
  },
  resource: UResource {
    id: 5678,
  }
}

sink:
UUri {
  authority: UAuthority {
    name: "Vehicle_2",
    domain: veh.com,
  },
  entity: UEntity {
    version_major: 1,
    id: 4321,
  },
  resource: UResource {
    id: 8765,
  }
}
----
topic messages are published to: `veh.com/Vehicle_1/veh.com:Vehicle_2/4321/1/8765`

to register a listener with this topic, the following source and sink filter would need to be provided:

[source]
----
source filter:
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    domain: veh.com,
  },
  entity: empty,
  resource: empty,
}

sink filter:
UUri {
  authority: UAuthority {
    name: "Vehicle_2",
    domain: veh.com,
  },
  entity: UEntity {
    version_major: 1,
    id: 4321,
  },
  resource: UResource {
    id: 8765,
  }
}
----

==== Example 2: Publish Message Type

[source]
----
source:
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    domain: veh.com,
  },
  entity: UEntity {
    version_major: 1,
    id: 1234,
  },
  resource: UResource {
    id: 5678,
  }
}

sink: None
----

topic messages are published to: `veh.com/Vehicle_1//1234/1/5678`

to register a listener with this topic, the following source filter would need to be provided:

[source]
----
source filter:
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    domain: veh.com,
  },
  entity: UEntity {
    version_major: 1,
    id: 1234,
  },
  resource: UResource {
    id: 5678,
  }
}
----

==== Example 3: Subscribe to all incoming messages to a UAuthority

[source]
----
source filter: empty

sink filter:
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    domain: veh.com,
  },
  entity: empty,
  resource: empty,
}
----

topic: `+/+/veh.com:Vehicle_1/+/+/+`

==== Example 4: Subscribe to all publish messages from a UAuthority

[source]
----
source filter:
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    domain: veh.com,
  },
  entity: empty,
  resource: empty,
}

sink filter: None
----

topic: `veh.com/Vehicle_1//+/+/+`

==== Example 5: Subscribe to all publish messages from a domain

[source]
----
source filter:
UUri {
  authority: UAuthority {
    name: empty,
    domain: veh.com,
  },
  entity: empty,
  resource: empty,
}

sink filter: None
----

topic: `veh.com/+//+/+/+`

==== Example 6: Subscribe to all messages sent from a UAuthority

This would include all message types.

[source]
----
source filter:
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    domain: veh.com,
  },
  entity: empty,
  resource: empty,
}

sink filter: empty
----

topic: `veh.com/Vehicle_1/+/+/+/+`

=== Payload Encoding

The MQTT payload **MUST** be a UPayload that is represented as a byte array to reduce size.
