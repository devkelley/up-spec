= MQTT Transport Protocol
:toc:
:sectnums:

The key words "*MUST*", "*MUST NOT*", "*REQUIRED*", "*SHALL*", "*SHALL NOT*", "*SHOULD*", "*SHOULD NOT*", "*RECOMMENDED*", "*MAY*", and "*OPTIONAL*" in this document are to be interpreted as described in https://www.rfc-editor.org/info/bcp14[IETF BCP14 (RFC2119 & RFC8174)]

----
Copyright (c) 2023 General Motors GTO LLC

Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.

SPDX-FileType: DOCUMENTATION
SPDX-FileCopyrightText: 2023 General Motors GTO LLC
SPDX-License-Identifier: Apache-2.0
----

== Overview

MQTT is an OASIS standard messaging protocol for the Internet of Things (IoT). It is designed as an extremely lightweight publish/subscribe messaging transport that is ideal for connecting remote devices with a small code footprint and minimal network bandwidth. MQTT today is used in a wide variety of industries, such as automotive, manufacturing, telecommunications, oil and gas, etc

For more information, please refer to https://mqtt.org/

== Specifications

=== UAttribute Mapping

MQTT 5 supports custom header fields, and we leverage this to map the UAttribute values into the MQTT header.

[cols="1,1"]
|===
| MQTT Header Property Code | Value (key:value)
| UserProperty
| ("id", "{UAttribute.id}")
| UserProperty
| ("type", "{UAttribute.type}")
| UserProperty
| ("source","{UAttribute.source}") # Short Form Serialized
| UserProperty
| ("sink","{UAttribute.sink}") # Short Form Serialized
| UserProperty
| ("priority","{UAttribute.priority}")
| CorrelationData
| ("reqid", "{UAttribute.reqId}")
| UserProperty
| ("ttl", "{UAttribute.ttl}") # Optional
| UserProperty
| ("permission_level", "{UAttribute.permissionLevel}") # Optional
| UserProperty
| ("commstatus", "{UAttribute.commStatus}") # Optional
| UserProperty
| ("token", "{UAttribute.token}") # Optional
| UserProperty
| ("traceparent", "{UAttribute.traceParent}") # Optional
|===


Most uAttributes are mapped to a MQTT header UserProperty with the exception of the reqId which is mapped to the CorrelationData property.

The source and sink fields **MUST** be a short form serialized UUri.

The type field is used by a UListener to select message types on the topic.

=== URI Mapping

The URI mapping follows the short form UUri format, with the addition of a location identifier to determine if the message is intended for a local or cloud destination.

* Publish Message
  - Use source UUri
  - {location_identifier}/{UUri.UAuthority.number (remote only)}/{UUri.UEntity.id}/{UUri.UEntity.version_major}/{UUri.UResource.id}

* Notification, Request or Response Message
  - Use sink UUri
  - {location_identifier}/{UUri.UAuthority.number (remote only)}/{UUri.UEntity.id}/{UUri.UEntity.version_major}/{UUri.UResource.id}

* Subscribe to all messages from a UAuthority (remote only)
  - {location_identifier}/{UUri.UAuthority.number}/+/+/+

Location Identifier is one of the following:
  - d2c - This is to identify remote messages going from a device to the cloud.
  - c2d - This is to identify remote messages going from the cloud to a device.
  - upl - This is to identify local messages on the device. (UAuthority.number is not used in this scenario).

Examples:

[source]
----
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    number: 192.168.0.0,
  },
  entity: UEntity {
    name: "body.access",
    version_major: 1,
    id: 1234,
  }
  resource: UResource {
    name: "door",
    instance: "front_left",
    message: "Door",
    id: 5678,
  }
}
----

* A Publish Message: `d2c/192.168.0.0/1234/1/5678`
* A Notification, Request or Response Message: `c2d/192.168.0.0/1234/1/5678`

Note: The kind of message should be determined using the Type UAttribute in the User Properites of the message.

[source]
----
UUri {
  authority: empty,
  entity: UEntity {
    name: "body.access",
    version_major: 1,
    id: 1234,
  }
  resource: UResource {
    name: "door",
    instance: "front_left",
    message: "Door",
    id: 5678,
  }
}
----

* All Message kinds: `upl/1234/1/5678`

Note: The kind of message should be determined using the Type UAttribute in the User Properites of the message.

If a UUri is provided with only a UAuthority we should subscribe to all topics under the UAuthority:

[source]
----
UUri {
  authority: UAuthority {
    name: "Vehicle_1",
    number: 192.168.0.0,
  },
  entity: empty,
  resource: empty,
}
----

* If in cloud, uses wildcard to subscribe to all messages from the UAuthority: `d2c/192.168.0.0/+/+/+`
* If on device, uses wildcard to subscribe to all messages from the UAuthority: `c2d/192.168.0.0/+/+/+`

=== Payload Encoding

The MQTT payload **MUST** be a UPayload that is represented as a byte array to reduce size.
